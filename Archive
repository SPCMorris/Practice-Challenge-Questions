/*These problems are in no particular order but you will find the harder ones near the end. Just saving these as a reference*/

/*If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.

Find the sum of all the multiples of 3 or 5 below 1000.*/

function sum1000(num) {
var storage = [], sum = 0;
	
	for(var i = 1; i < num; i++) {
		if((i % 3 === 0) || (i % 5 === 0)) {
			storage.push(i);
		}
	}
	
	for(var x in storage) {
		sum  = sum + storage[x];
	}
	
	return sum;
}

/*Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms 
will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.*/

function fib(numTerms) {                          //I misunderstood the question and first solved for the number of terms not value
var fibStor = [1,2];
	if(numTerms === 1) {
		return 1;
	} 
	for(var i = 0; i < numTerms-2; i++) {
		var counter = fibStor[i] + fibStor[i+1];
		fibStor.push(counter);
	}
		function sum(array) {
		var storage = [], total = 0;
		
			for(var i = 1; i < array.length; i++) {
				if(array[i] % 2 === 0) {
					storage.push(array[i]);
				}
			}
			
			for(var x in storage) {
				total += storage[x];
			}
			return total;
		}
	return sum(fibStor);
}
//This solution solves the question.

function evenSum(value) {
 var valueOne = 0, valueTwo = 1, sum = 0, fibStor = [], evenStor = [], total = 0;
 
  if(value === 1) {
    return 1;
  }
    for(var i = 0; i <= value; i ++) {   //creates the Fibonacci seq
     if(value > sum) {
      valueOne = valueTwo;
      valueTwo = sum;
      sum = valueOne + valueTwo;
      fibStor.push(sum);
     }
    }
  for(var x in fibStor) {              // extracts the evens
    if(fibStor[x] % 2 === 0) {
      evenStor.push(fibStor[x]);
    }
  }
  
  for(var y in evenStor) {            // sums the evens
    total+= evenStor[y];
  }
  
  
  
  return total;
}

/*The prime factors of 13195 are 5, 7, 13 and 29.

What is the largest prime factor of the number 600851475143 ?*/                

function prime(num) {
var primeStor = [], primeOfNum = [], counter = 0, largestPrime = 0;
  
   for(var i = 0; i <= num; i ++) {                              
     if((i === 2 || i === 3 || i === 5)) {
        primeStor.push(i);
      } else if(i % 2 !== 0 && i % 3 !== 0 && i !== 1) {
        primeStor.push(i);
      }
  }
  
  for(var x in primeStor) {                                     //extracts all prime factors except for 2,3,5
    if(num % primeStor[x] === 0) {
      primeOfNum.push(primeStor[x]);
    }
  }
  
  for(var j = 0; j < primeOfNum.length; j++) {
    counter = primeOfNum[j] * primeOfNum[j+1];
    for(var k = 0; k <primeOfNum.length; k++) {
      if(counter === primeOfNum[k]) {
        counter = primeOfNum[k-1];
        return counter;                                          //doesnt work when the prime factor is 2 or 3
      }
    }
  }
  
  return counter;
  
}

//reversing a string

function FirstReverse(str) { 
var back = [];
var x = str.length;
  
	while(x > 0) {
		var y = str.substring(x-1, x);
		back.push(y);
		x--;
}
  return back.join(''); 
         
}


//Factorial A

function FirstFactorial (num) {
var a = num;
var b = 1;
var total = a;
var factorial = [];	
  
	while(a > 1) {
		a--;
		factorial.push(num-b);
		b++;
}
	for(i = 0; i < num-1; i++) {
		output = factorial[i];
		total = output * total;
		a--;
	}
	
	return total;
}

//Factorial B

function factorialRecur(num) {
  if(num === 1) {
  return 1;
  } else {
  return num * factorialRecur(num-1);
  }
}

//Longest Word

function LongestWord(sen) { 
sen = sen.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()\[\]]/g,"");
var array = sen.split(" ");
var answer = '';
	
	for(var i = 0; i < array.length; i++) {
		for(var j in array) {
			if(array[i].length < array[j].length) {
				return answer = array[j];
			} else if(array[i].length == array[j].length) {
				return answer = array[i];
			}
		}
	}
}

//Letter Change
function LetterChanges(str) { 
var abc = 'abcdefghijklmnopqrstuvwxyz';
var vowels = 'aeiou';
var result = [];
var counter = 0;	
	for(var i = 0; i < str.length; i++) {
		for(var j = 0; j < abc.length; j++) {
			if(abc[j] === str[i]) {
				result.push(abc[j+1]);
			} 
		}
		counter++;
		if(result.length < counter) {
			result.push(str[i]);
		}
	}
	for(var k = 0; k < result.length; k++) {
		for(var l = 0; l < vowels.length; l++) {
			if(result[k] === vowels[l]) {
				result.splice(result.indexOf(result[k]),1,vowels[l].toUpperCase());
			} 
		}
	}
     return result;    
}

/*An isogram is a word that has no repeating letters, consecutive or non-consecutive. 
Implement a function that determines whether a string that contains only letters is an isogram. Assume the empty string is an isogram. 
Ignore letter case.

isIsogram( "Dermatoglyphics" ) == true
isIsogram( "aba" ) == false
isIsogram( "moOse" ) == false // -- ignore letter case */

function isIsogram(str){
var lowerCase = str.toLowerCase();
var answer = 0;

 
for(var i = 0;i < str.length; i++) {
	for(var j = i+1;j < str.length; j++){
		
		if(lowerCase.charAt(i) == lowerCase.charAt(j)) {
			answer = false;
		} 
	}
}
	if(answer === 0) {
		answer = true;
	}
  return answer;
}

/*Given a string which may include opening or closing round brackets, can you tell whether the string contains a balanced pair(s) of
round brackets, that is there are no brackets which are either opened & not closed, or vice versa. Opening round brackets always have
to come before closing bracket. An empty string is balanced. FAILED*/


function isBalanced(string){
var arrayResult =[];
var result;
var parLeft = 0;
var parRight = 0;
	
	for (var k = 0; k <= string.length; k++) {
		string.slice(" ");
		arrayResult.push(string[k]);
	}
	for(var x = 0; x < arrayResult.length; x++) {
		if(arrayResult[x] === "(") {
			parLeft = parLeft + 1;
		}	
	}
	for(var y = 0; y < arrayResult.length; y++) {
		if(arrayResult[y] === ")") {
			parRight = parRight + 1;
		}	
	}
	for(var a = 0; a < 100; a++) {
		if(parLeft == a && parRight == a){
		result = true;
		}	else if( parLeft == a && parRight == a){
			result = true;
			} 
	}
		if(string.length === 0) {
			result = true;
	}
		if(result !== true) {
			return false;
	}	
	return result;
}

/*In this Kata we will play a classic game of Tug-o'-War!

Two teams of 5 members will face off, the strongest of which will prevail. Each team member will be assigned a strength rating (1-9), 
with the most powerful members having a rating of 9. Your goal is to determine, based on the cumulative strength of the members of each team, 
which team will win the war.

The teams will be represented by an array of arrays:

[[5,0,3,2,1], [1,6,8,2,9]]  // 11 < 26 ; "Team 2 wins!"
Your task is to return a string with which team won or if it was a tie.

If team one is stronger, return the string "Team 1 wins!"
If team two is stronger, return the string "Team 2 wins!"
If the two teams are of equal strength, the team with the strongest Anchor (the member furthest from the center of the rope) will win. 
In the above example, the member with strength 5 is team one's Anchor and strength 9 is team two's Anchor.

If the teams and the Anchors are both of equal strength, return the string "It's a tie!"*/

var team1 = [];
var team2 = [];
function tug_o_war(teams) {
	for(var x = 0; x < teams[0].length; x++) {
		var cutUp = teams[0].slice(0, teams[0].length);
		team1.push(cutUp[x]);
	}
	for(var y = 0; y < teams[0].length; y++) {
		var cutUp1 = teams[1].slice(0, teams[0].length);
		team2.push(cutUp1[y]);
	}
	fight(team1, team2);

function fight(team1, team2) {
var teamSum1 = 0;
var teamSum2 = 0;
	for( var i = 0; i < team1.length; i++) {
		teamSum1 = team1[i] + teamSum1;
		teamSum2 = team2[i] + teamSum2;
	}
	if(teamSum1 > teamSum2) {
		console.log("Team 1 wins!");
	}
	else if(teamSum1 < teamSum2) {
		console.log("Team 2 wins!");
	}
	
	else if (team1[0] > team2[team2.length-1]) {
		console.log("Team 1 wins!");
	}
	else if (team1[0] < team2[team2.length-1]) {
		console.log("Team 2 wins!");
	}
	else if (teamSum1 === teamSum2) {
		console.log("It's a tie!");
	}
}
}

/* Compelete the Pattern #2

You have to write a function pattern which returns the following Pattern(See Pattern & Examples) upto n number of rows.

Note:Returning the pattern is not the same as Printing the pattern.
Rules/Note:

If n < 1 then it should return "" i.e. empty string.
There are no whitespaces in the pattern.*/

function pattern(n){
var outputStr="";
var outputFinal = outputStr;
	if(n == 1) {
		return "1";
	}
	for(var i = n; i > 0; i--) {
		outputStr = outputStr + i.toString();
	}
  if(n < 10) {
	for(var j = n; j > 0; j--) {
		outputFinal = outputFinal + "\n" + outputStr.substring(0,j);
	}
  }
	if(n >= 10) {
		for(var k = n; k > 1; k--) {
		outputFinal = outputFinal + "\n" + outputStr.substring(0,k);
	}
	}
	return console.log(outputFinal);
}

pattern(11);

/*Vampire Numbers

Our loose definition of Vampire Numbers can be described as follows:

6 * 21 = 126
# 6 and 21 would be valid 'fangs' for a vampire number as the 
# digits 6, 1, and 2 are present in both the product and multiplicands

10 * 11 = 110
# 110 is not a vampire number since there are three 1's in the
# multiplicands, but only two 1's in the product
Create a function that can receive two 'fangs' and determine if the product of the two is a valid vampire number.*/

var vampire_test = function(a, b){
	var product = (a * b).toString().split('');
	var aString = (a).toString();
	var bString = (b).toString();
	var testVariable = (aString + bString).split('');        //turn both into arrays so I can use sort on them
	
	for(var i = 0; i <= testVariable.length; i++) {
		if(testVariable[i] === "-") {
			testVariable.splice(i,i-1);           //have to remove the "-" before sort because it screws up the order
		}
	}
	product.sort(function(a,b){
		return a - b;
	});
	
	testVariable.sort(function(a,b){
		return a - b;
	});
	
	if(product[0] === '-') {            //I removed "-" after the sort on product because sort would leave it in [0]
		product.splice(0,1);
	}
	
	function stringEmUp() {                   //practicing closures/callbacks so using them as much as I can
		var answer1 = product.join('');
		var answer2 = testVariable.join('');
		
		if(answer1 === answer2) {
			return true;
		} else {
			return false;
		}
	}
	
	
	return stringEmUp();
	
};

console.log(vampire_test(21,6));

/*Deutschstunde
Everybody knows a little german, right? But remembering the correct articles is a tough job. Write yourself a little helper, that 
returns the noun with the matching article:

each noun containing less than 2 vowels has the article "das"
each noun containing 2-3 vowels has the article "die"
each noun containing more than 3 vowels has the article "der"
Caution: Vowels are "a,e,i,o,u". Umlaute (ä ö ü) are also being counted!

(This Kata is a joke, there is no such grammar rule!)*/

function derDieDas(wort){
var vowels = ['a','e','i','o','u','ä','ö','ü'];
var wortArray = wort.toLowerCase().split('');
	
	var das = [];
	var die = [];
	var der = [];

 
	for(var i = 0; i < vowels.length; i++) {
		for(var j = 0; j < wortArray.length; j++) {
			if(vowels[i] == wortArray[j]) {
					das.push(wortArray[j]);
					die.push(wortArray[j]);
					der.push(wortArray[j]);
			}
		}
	}
	if(das.length < 2) {
		return 'das ' + wort;
	} else if(die.length === 2 || die.length == 3) {
		return 'die ' + wort;
	} else if(der.length > 3) {
		return 'der ' + wort;
	}
}

/*String to integer conversion
JavaScript provides a built-in parseInt method.

It can be used like this:

parseInt("10") returns 10
parseInt("10 apples") also returns 10
We would like it to return "NaN" (as a string) for the second case because the input string is not a valid number.

You are asked to write a myParseInt method with the following rules:

It should make the conversion if the given string only contains a single integer value (and eventually spaces - including tabs, line 
feeds... - at both ends). For all other strings (including the ones representing float values), it should return NaN
It should assume that all numbers are not signed and written in base 10*/


function myParseInt(str) {
var strArray = str.split('');
var unwanted = [];
var wanted = [];
	
	for(var i = 0;i < strArray.length; i++) {
		if (isNaN(strArray[i])) {        //remove unwanted string items
			unwanted.push(strArray[i]);
		} else {
			wanted.push(strArray[i]);
		}
	}
	if(unwanted.length > 0) {         //if this has any length then there are string items in the property 
		return 'NaN';                   //passed to myParseInt
	}
	return Number(wanted.join(''));   // use join and number to convert back to string then a number to remove 
                                    //spaces and return number value
}

/*Jaden Smith, the son of Will Smith, is the star of films such as The Karate Kid (2010) and After Earth (2013). 
Jaden is also known for some of his philosophy that he delivers via Twitter. When writing on Twitter, he is known for almost always 
capitalizing every word.

Your task is to convert strings to how they would be written by Jaden Smith. The strings are actual quotes from Jaden Smith, but they
are not capitalized in 
the same way he originally typed them.*/

String.prototype.toJadenCase = function () {
var str = this.split(" ");
	for(var i in str) {
		if(str[i][0] != str[i][0].toUpperCase()) {
			str[i] = str[i].replace(str[i][0], str[i][0].toUpperCase());
		}
	}
	return str.join(" ");
};

/*Welcome. In this kata you are required to, given a string, replace every letter with its position in the alphabet. If anything in
the text isn't a letter, ignore it and don't return it. a being 1, b being 2, etc. As an example:

alphabet_position("The sunset sets at twelve o' clock.")
Should return "20 8 5 19 21 14 19 5 20 19 5 20 19 1 20 20 23 5 12 22 5 15 3 12 15 3 11" (As a string.)*/

function alphabetPosition(text) {
var abc = 'abcdefghijklmnopqrstuvwxyz'.split('');
var numAbc = [];	
text = text.toLowerCase().replace(/[.,?!\'\'\"\"]/g,"").split('');
var result = [];

	abc.forEach(function(letter) {
		var count = abc.indexOf(letter);
			numAbc.push(count+1);
	});
	
	for(var i = 0; i < text.length; i++) {
		for(var j = 0; j < abc.length; j++) {
			if(text[i] === abc[j]) {
				result.push(numAbc[j]);
			}
		}
	}
	
	return result.join(" ");
}

/*Given a list of integers and a single sum value, return the first two values (parse from the left please) in order of appearance 
that add up to form the sum.

sum_pairs([11, 3, 7, 5],         10)
#              ^--^      3 + 7 = 10
== [3, 7]

sum_pairs([4, 3, 2, 3, 4],         6)
#          ^-----^         4 + 2 = 6, indices: 0, 2 *
#             ^-----^      3 + 3 = 6, indices: 1, 3
#                ^-----^   2 + 4 = 6, indices: 2, 4
#  * entire pair is earlier, and therefore is the correct answer
== [4, 2]

sum_pairs([0, 0, -2, 3], 2)
#  there are no pairs of values that can be added to produce 2.
== None/nil/undefined (Based on the language)

sum_pairs([10, 5, 2, 3, 7, 5],         10)
#              ^-----------^   5 + 5 = 10, indices: 1, 5
#                    ^--^      3 + 7 = 10, indices: 3, 4 *
#  * entire pair is earlier, and therefore is the correct answer
== [3, 7]
Negative numbers and duplicate numbers can and will appear.

NOTE: There will also be lists tested of lengths upwards of 10,000,000 elements. Be sure your code doesn't time out.*/

function sum_pairs(ints, s){	
	for(var i = 0; i <= ints.length; i++) {
		for(var j = 0; j <= ints.length; j++) {
			var x = ints.indexOf(ints[i]);						/*need to fix this. It needs to return the pairs closest to each other*/
			var y = ints.indexOf(ints[j]);
				if(ints[i] + ints[j] === s && x != y) {
					return [ints[i], ints[j]];
				} 
				if(ints[i] === ints[j+1] && ints[i] + ints[j+1] === s) {
					return [ints[i], ints[j+1]];
				}
		}
	}
	return undefined;
}

// Number-Star ladder: using n as a parameter in the calling function pattern, where n should be a natural number; complete the codes to get the pattern (take the help of examples).

function pattern(n) {
 var output = '1', sign = '', endNum = 1;
  
  for(var i = 1; i < n; i++) {
    endNum++;
    sign+= '*';
    output+= '\n1' + sign + endNum;
  }
  return output;
}

/*Bob is preparing to pass IQ test. The most frequent task in this test is to find out which one of the given numbers differs from the 
others. Bob observed that one number usually differs from the others in evenness. Help Bob — to check his answers, he needs a program
that among the given numbers finds one that is different in evenness, and return a position of this number.

! Keep in mind that your task is to help Bob solve a real IQ test, which means indexes of the elements start from 1 (not 0)*/

function iqTest(numbers){
numbers = numbers.replace(/\s/g, ",");
var strStor = "", storage =[], even = [], odd = [];
  
 for(var i = 0; i < numbers.length;i++) {
   if(numbers[i] !== ',') {
     strStor+= numbers[i];
   } else {
     storage.push(Number(strStor));
     strStor = "";
   }
 }
  storage.push(Number(strStor)); 
  
    for(var item in storage) {
      if(storage[item] % 2 === 0) {
        even.push(storage[item]);
      } else {
        odd.push(storage[item]);
      }
    }
      if(even.length === 1) {
        for(var j = 0; j < storage.length; j++) {
          if(even[0] === storage[j]) {
            return j+1;
          }  
        }
      } else {
         for(var k = 0; k < storage.length; k++) {
          if(odd[0] === storage[k]) {
            return k+1;
          }  
        }
      }
}

/*Word a10n (abbreviation)

The word i18n is a common abbreviation of internationalization the developer community use instead of typing the whole word and trying 
to spell it correctly. Similarly, a11y is an abbreviation of accessibility.

Write a function that takes a string and turns any and all words within that string of length 4 or greater into an abbreviation 
following the same rules.

Notes:

A "word" is a sequence of alphabetical characters. By this definition, any other character like a space or hyphen (eg. "elephant-ride") will split up a series of letters into two words (eg. "elephant" and "ride").
The abbreviated version of the word should have the first letter, then the number of removed characters, then the last letter 
(eg. "e6t-r2e").*/

function abbreviate(string) {
var reg = /([^a-zA-Z0-9])/i;
var string = string.split(reg), result = [];

 for(var i in string) {
   if(string[i].length >= 4) {
     var x = string[i].length;
     result.push(string[i][0] + (x-2)+ string[i][x-1]);
   } else {
     result.push(string[i]);                                                           
   }
 }
  return result.join("");
}

1.
// returns sum of any array and removes strings

var x = [1, 2,"I love", null, 3, 4, 5];

function sum (arrayOne) {
var numArray = [];
var y = 0;
var total = 0;
	
	for(var i = 0; i < arrayOne.length; i++) {
		
		if(isNaN(arrayOne[i])) {
			numArray.push(0);
			
		} else {
			numArray.push(arrayOne[i]);
		}
	}	
while (y < numArray.length) {
	
	total = numArray[y] + total;
	y++;
}
	
	return total;
}

2.
//return the amount of times the highest occuring item appears in an array

var arr = [1,2,1,2,'a','a','a'];

function test () {
	// object needs to be created {1:2, 2:1}
	var storage = {}, counterStor = [];
	
	for(var i = 0; i < arr.length; i++) {
		if(storage.hasOwnProperty(arr[i])) {
			storage[arr[i]] = storage[arr[i]] + 1;
		} else {
			storage[arr[i]] = 1;
		}
	}
	
	for(var j in storage) {
		counterStor.push(storage[j]);
	}
	
var answer = counterStor.sort(function(a,b){return b-a;});
	
	return answer[0];
}

3. 

//I created this function that can flatten a multidimensional array of any size

function flattenAll(arr) {
 var storage = [];
  
  function flatten(arr) {
    arr.forEach(function(item){
      if(Array.isArray(item)) {
        flatten(item);
      } else {
      storage.push(item);
      }
    });
  }
  flatten(arr);
  return storage;
}

/*create an object named slamBook. It has the following properties and value pairs:
name = your name/age= your age/address = object with properties street, city, state/married = boolean value/ myHobbies = array of 
your hobbies/ luckyNumbers = array of integers / bestfriends = array of names and their ages  */

var slamBook = {
  name: "Ryan",
  age: 29,
  address: {street: "4101 California", city: "Bakersfield", state: "CA"},
  married: true,
  myHobbies: ["cooking", "gaming", "weekend trips"],
  luckyNumbers: [7,13],
  bestFriends: ["Nick", "Casey", "Kyle", 29]
};

/*write a function that would count the number of string values in the object you created */

function countStr (obj) {
var count = 0;
  
  for(var i in obj) {
    if(typeof obj[i] === 'string') {
      count++;
    } else if(typeof obj[i] === 'object') {
      for(var el in obj[i]) {
        if(typeof obj[i][el] === 'string') {
          count++;
        }
      }
    }
  }
  return count;
}

console.log(countStr(slamBook));

/* given two objects: var obj1 = {a:10, b:13, c:20, d:16} and var obj2 = {a:16, c:15, d:25, e:7}
write a function that would return a single object that would combine/add up all the property value pairs */
var obj1 = {a:10, b:13, c:20, d:16};
var obj2 = {a:16, c:15, d:25, e:7};


function countVal(obj1, obj2) {
 var count = 0, newObj = {total: 0};
  
  function addUp(obj) {
    for(var i in obj) {
      if(newObj.hasOwnProperty(i)) {
        count+= obj[i];
        newObj[i] = newObj[i] + obj[i];
     } else {
         count+= obj[i];
         newObj[i] = obj[i];
     }
    }
  }
  addUp(obj1); 
  addUp(obj2);
  newObj.total = count;
  return newObj;
}

console.log(countVal(obj1,obj2));

